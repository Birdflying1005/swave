<!doctype html>
<html class="fixed sidebar-light">
<head>
    <meta charset="UTF-8">

    <title>Sync vs. Async Â· swave</title>
    <meta name="keywords" content="scala, streams, streaming, reactive, asynchronous, non-blocking" />
    <meta name="description" content='A Reactive Streams infrastructure implementation in Scala'>
    <meta name="author" content="The swave team">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,800|Shadows+Into+Light" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../../assets/css/theme.css" />
    <link rel="stylesheet" href="../../assets/css/skins/default.css" />
    <link rel="stylesheet" href="../../assets/css/theme-custom.css">
    <link rel="stylesheet" href="../../assets/vendor/highlight/github.css">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="apple-mobile-web-app-title" content="swave.io">
    <meta name="application-name" content="swave.io">
    <meta name="theme-color" content="#ffffff">

    <script src="../../assets/vendor/modernizr/modernizr.js"></script>
</head>
<body >
<section class="body">

    <header class="header">
        <div class="logo-container">
            <a href="../../index.html" class="logo">
                <img src="../../assets/img/swave-logo.svg" height="35" alt="swave" />
            </a>
            <div class="visible-xs toggle-sidebar-left" data-toggle-class="sidebar-left-opened" data-target="html" data-fire-event="sidebar-left-opened">
                <i class="fa fa-bars" aria-label="Toggle sidebar"></i>
            </div>
        </div>

        <div class="header-right hidden-xs">
            <ul class="social-icons">
                <li class="social-icons-github"><a href="https://github.com/sirthias/swave/" target="_blank" title="Github"><i class="fa fa-github"></i></a></li>
                <li class="social-icons-email"><a href="https://groups.google.com/forum/#!forum/swave-user" target="_blank" title="Mailing List"><i class="fa fa-envelope"></i></a></li>
                <li class="social-icons-twitter"><a href="https://twitter.com/swaveio/" target="_blank" title="Twitter"><i class="fa fa-twitter"></i></a></li>
            </ul>
            <div id="talks-link">
                <a href="../../introduction/talks-on-swave.html" title="Watch the latest introductory talks for swave!">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>&nbsp;
                    <i class="fa fa-video-camera" aria-hidden="true"></i>&nbsp;Watch an intro talk on swave!&nbsp;
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </header>

    <div class="inner-wrapper">
        <aside id="sidebar-left" class="sidebar-left">

            <div class="sidebar-header">
                <div class="sidebar-title">
                    Content
                </div>
                <div class="sidebar-toggle hidden-xs" data-toggle-class="sidebar-left-collapsed" data-target="html" data-fire-event="sidebar-left-toggle">
                    <i class="fa fa-bars" aria-label="Toggle sidebar"></i>
                </div>
            </div>

            <div class="nano">
                <div class="nano-content">
                    <nav id="menu" class="nav-main" role="navigation">
                        <ul class="nav nav-main">
                          <li class="nav-parent"><a><i class="fa fa-blind" aria-hidden="true"></i><span>Introduction</span></a>
                          <ul class="nav nav-children">
                            <li><a href="../../introduction/overview.html">Overview</a></li>
                            <li><a href="../../introduction/reactive-streams.html">Reactive Streams</a></li>
                            <li><a href="../../introduction/swave-vs-akka-stream.html"><em>swave</em> vs. Akka-Stream</a></li>
                            <li><a href="../../introduction/talks-on-swave.html">Talks on <em>swave</em></a></li>
                          </ul></li>
                          <li class="nav-parent nav-expanded nav-active"><a><i class="fa fa-book" aria-hidden="true"></i><span>User Documentation</span></a>
                          <ul class="nav nav-children">
                            <li class="nav-parent"><a>Show-Off</a>
                            <ul class="nav nav-children">
                              <li><a href="../../usage/show-off/overview.html">Show-Off Overview</a></li>
                              <li><a href="../../usage/show-off/md5.html">MD5 Example</a></li>
                              <li><a href="../../usage/show-off/fahrenheit.html">Fahrenheit Example</a></li>
                              <li><a href="../../usage/show-off/monte-carlo-pi.html">Monte Carlo Pi Example</a></li>
                              <li><a href="../../usage/show-off/fibonacci.html">Fibonacci Example</a></li>
                            </ul></li>
                            <li><a href="../../usage/setup.html">Setup</a></li>
                            <li><a href="../../usage/quick-start.html">Quick Start</a></li>
                            <li><a href="../../usage/basics.html">Basics</a></li>
                            <li><a href="../../usage/spouts.html">Spouts</a></li>
                            <li><a href="../../usage/drains.html">Drains</a></li>
                            <li class="nav-parent"><a>Transformations</a>
                            <ul class="nav nav-children">
                              <li><a href="../../usage/transformations/overview.html">Transformations Overview</a></li>
                              <li><a href="../../usage/transformations/simple.html">Simple Transformations</a></li>
                              <li><a href="../../usage/transformations/fan-ins.html">Fan-Ins</a></li>
                              <li><a href="../../usage/transformations/fan-outs.html">Fan-Outs</a></li>
                              <li><a href="../../usage/transformations/streams-of-streams.html">Streams-of-Streams</a></li>
                              <li><a href="../../usage/transformations/relationships.html">Fan-In/Out Relationships</a></li>
                              <li><a href="../../usage/transformations/couplings.html">Couplings</a></li>
                              <li><a href="../../usage/transformations/reference/index.html">Transformation Reference</a></li>
                            </ul></li>
                            <li class="nav-parent nav-expanded nav-active"><a>Further Topics</a>
                            <ul class="nav nav-children">
                              <li class="nav-expanded nav-active"><a href="../../usage/further/sync-vs-async.html">Sync vs. Async</a></li>
                              <li><a href="../../usage/further/pipes.html">Pipes</a></li>
                              <li><a href="../../usage/further/modules.html">Modules</a></li>
                              <li><a href="../../usage/further/debugging.html">Debugging</a></li>
                              <li><a href="../../usage/further/rendering.html">Rendering</a></li>
                              <li><a href="../../usage/further/configuration.html">Configuration</a></li>
                              <li><a href="../../usage/further/best-practices.html">Best Practices</a></li>
                            </ul></li>
                            <li class="nav-parent"><a>Domain Adapters</a>
                            <ul class="nav nav-children">
                              <li><a href="../../usage/domain/file-io.html">File IO</a></li>
                              <li><a href="../../usage/domain/tcp.html">Network IO (TCP)</a></li>
                              <li><a href="../../usage/domain/text.html">Text Transformations</a></li>
                              <li><a href="../../usage/domain/hash.html">Hashing Support</a></li>
                            </ul></li>
                            <li><a href="../../usage/swave-core-api.html">API Docs (ScalaDoc)</a></li>
                            <li><a href="../../usage/swave-akka-compat/index.html">swave-akka-compat</a></li>
                            <li><a href="../../usage/swave-scodec-compat/index.html">swave-scodec-compat</a></li>
                            <li><a href="../../usage/swave-testkit/index.html">swave-testkit</a></li>
                          </ul></li>
                          <li><a href="../../dev/index.html"><i class="fa fa-cogs" aria-hidden="true"></i><span>Developer Documentation</span></a></li>
                          <li class="nav-parent"><a><i class="fa fa-info-circle" aria-hidden="true"></i><span>Project Info</span></a>
                          <ul class="nav nav-children">
                            <li><a href="../../project/license.html">License</a></li>
                            <li><a href="../../project/contributing.html">Contributing</a></li>
                            <li><a href="../../project/changelog.html">Changelog</a></li>
                            <li><a href="../../project/sponsors.html">Sponsors</a></li>
                            <li><a href="../../project/references.html">References</a></li>
                          </ul></li>
                          <li><a href="../../support.html"><i class="fa fa-users" aria-hidden="true"></i><span>Support</span></a></li>
                        </ul>
                    </nav>
                </div>

                <script>
                    // Maintain Scroll Position
                    if (typeof localStorage !== 'undefined') {
                        if (localStorage.getItem('sidebar-left-position') !== null) {
                            var initialPosition = localStorage.getItem('sidebar-left-position'),
                                    sidebarLeft = document.querySelector('#sidebar-left .nano-content');

                            sidebarLeft.scrollTop = initialPosition;
                        }
                    }
                </script>

            </div>

        </aside>

        <section role="main" class="content-body">
            <header class="page-header">
                <ul class="breadcrumbs">
                  <li><a href="../../index.html"><i class="fa fa-home"></i></a></li>
                  <li><a href="../../usage/index.html">User Documentation</a></li>
                  <li><a href="../../usage/further/index.html">Further Topics</a></li>
                  <li>Sync vs. Async</li>
                </ul>
            </header>
            <div id="main-content">
                <!-- start: page -->
<h1><a href="#sync-vs-async" name="sync-vs-async" class="anchor"><span class="anchor-link"></span></a>Sync vs. Async</h1>
<p>As already pointed out in the <a href="../quick-start.html#running-a-stream">Quick Start</a> and <a href="../basics.html#execution-model">Basics</a> chapters <em>swave</em> supports running streams synchronously, on the caller thread, as well as asynchronously, off the caller thread, on one or more configurable thread-pools.</p>
<h2><a href="#synchronous-execution" name="synchronous-execution" class="anchor"><span class="anchor-link"></span></a>Synchronous Execution</h2>
<p>Running a stream synchronously on the caller thread means that the <code>streamGraph.run()</code> call will not only <em>start</em> the stream execution but actually <em>perform</em> the stream execution, in its entirety. Since no inter-thread communication is required in these cases the overall runtime overhead introduced by the streaming infrastructure is quite small, which can cause simple streams to run much faster than in comparable asynchronous setups.</p>
<p>However, since everything runs only on one thread there is no way to make use of any potentially existing parallelism in the hardware. Also, the stream cannot contain any stages that need to react to signals from outside the stream (like timers, interrupts, callbacks, etc.). The respective reference documentation for <a href="../transformations/reference/index.html">transformations</a>, <a href="../spouts.html">Spouts</a> and <a href="../drains.html">Drains</a> will tell you whether the underlying stage is able to run synchronously or not.</p>
<p>If a stream runs synchronously and <code>run().result</code> returns a <a href="http://www.scala-lang.org/api/2.12.1/scala/concurrent/Future.html">Future</a> then the returned <code>Future</code> instance will be already completed when the <code>run()</code> call returns. It might be though that the <code>Future</code> is completed with an error (i.e. a <a href="http://www.scala-lang.org/api/2.12.1/scala/util/Failure.html">Failure</a> instance) rather than the expected result value, for example because some element of the stream graph threw an exception during execution. The <code>run()</code> call itself will never throw an exception that is triggered during the runtime of a stream. It will throw an exception though when the stream cannot be started because the stream definition is illegal (e.g. because there are still unconnected ports). If you need something is guaranteed to <em>never</em> throw use <code>tryRun()</code>. </p>
<p>Here is an example of a <a href="../transformations/reference/map.html">map</a> stage that throws an exception when processing one particular stream element:</p>
<pre><code class="scala">import scala.concurrent.Future
import scala.util.Failure
import swave.core._

implicit val env = StreamEnv()

val result: Future[Seq[Int]] =
  Spout.ints(0)
    .map(i =&gt; 1000 / (i - 10))
    .take(50)
    .to(Drain.seq(limit = 50)).run().result // shortcut: .drainToVector(limit = 50)

result.value.get shouldBe a [Failure[_]]

the [ArithmeticException] thrownBy result.value.get.get should have message &quot;/ by zero&quot;</code></pre>
<p>Note that &ldquo;running synchronously&rdquo; doesn&rsquo;t mean that there is blocking involved! The limits on what can run synchronously are established precisely because no stage is allowed to ever block. Whenever a stage might have a reason to block, e.g. because it needs to wait for the completion of a <a href="http://www.scala-lang.org/api/2.12.1/scala/concurrent/Future.html">Future</a>, it cannot run synchronously and needs to be notified of the event it is interested in in an asynchronous fashion.</p>
<h2><a href="#asynchronous-execution" name="asynchronous-execution" class="anchor"><span class="anchor-link"></span></a>Asynchronous Execution</h2>
<p><em>swave</em> will run a stream synchronously whenever it can, which is only the case when all <a href="../spouts.html">Spouts</a>, <a href="../drains.html">Drains</a> and <a href="../transformations/reference/index.html">transformations</a> in the stream graph (including potentially existing nested graphs) support this mode of execution.</p>
<p>To better understand how <em>swave</em> will behave by default and how you can control asynchronous execution in a fine-grained fashion let&rsquo;s look at a simple example:</p>
<pre><code class="scala">import scala.concurrent.Future
import swave.core._

implicit val env = StreamEnv()

val result: Future[List[String]] =
  Spout.ints(0)
    .filter(_ % 5 == 0)
    .map(_.toString)
    .take(10)
    .drainToList(limit = 100) // shortcut for `to(...).run().result`

result.value.get.get shouldEqual (0 to 45 by 5).map(_.toString)</code></pre>
<p>Here is the stream graph of this example, which also shows which stage will run on which thread / dispatcher:</p>
<p>As you can see everything will run on the caller thread, i.e. synchronously.</p>
<h3><a href="#async" name="async" class="anchor"><span class="anchor-link"></span></a><code>async</code></h3>
<p>Suppose now that we&rsquo;d like to run this stream graph as is but off the caller thread, e.g. because it takes some longer amount of time to finish and we&rsquo;d like to use the caller thread for something else.</p>
<p>We can do so by simply adding an <a href="../transformations/reference/async.html">async</a> transformation to the graph at an arbitrary position:</p>
<pre><code class="scala">import scala.concurrent.Future
import swave.core.util._
import swave.core._

implicit val env = StreamEnv()

val result: Future[Seq[String]] =
  Spout.ints(0)
    .filter(_ % 5 == 0)
    .map(_.toString)
    .take(10)
    .async()
    .drainToList(limit = 100) // shortcut for `to(...).run().result`

result.await() shouldEqual (0 to 45 by 5).map(_.toString)

env.shutdown()</code></pre>
<p>Now the <code>drainToList(...)</code> returns immediately, likely before the produced <code>Future</code> value has been fulfilled. We therefore have to explicitly await the <code>Future</code> value in order to get a hold of it. <br/> (Note that <code>await</code> is <strong>blocking</strong> and therefore only allowed in exceptional circumstances, like this test here!)</p>
<p>The graph still looks the same but is now run on the default dispatcher. Since no asynchronous boundaries have been introduced it will still run as one single block:</p>
<p>The <a href="../transformations/reference/async.html">async</a> transformation has no effect on the data or the demand travelling through it. All it does is forcing the stream graph it&rsquo;s part of into running asynchronously. It has one optional parameter: the name of a <a href="configuration.html">configured</a> dispatcher to be used. If not specified then the default dispatcher will be assigned if no other assignment has been made for the <em>async region</em> the drain is placed in (we&rsquo;ll talk about async regions in a bit.)</p>
<h3><a href="#async-transformations" name="async-transformations" class="anchor"><span class="anchor-link"></span></a>Async Transformations</h3>
<p>Another way to move the execution of a stream graph off the caller thread is the addition of an <a href="../transformations/simple.html#asynchronous-simple-transformations">asynchronous transformation</a> that cannot run synchronously. We could for example add an <a href="../transformations/reference/withCompletionTimeout.html">withCompletionTimeout</a> transformation to the graph to make sure it will never run for longer than one second:</p>
<pre><code class="scala">import scala.concurrent.duration._
import scala.concurrent.Future
import swave.core.util._
import swave.core._

implicit val env = StreamEnv()

val result: Future[List[String]] =
  Spout.ints(0)
    .filter(_ % 5 == 0)
    .map(_.toString)
    .take(10)
    .withCompletionTimeout(1.second) // cannot run synchronously
    .drainToList(limit = 100)

result.await() shouldEqual (0 to 45 by 5).map(_.toString)

env.shutdown()</code></pre>
<p>Since <a href="../transformations/reference/withCompletionTimeout.html">withCompletionTimeout</a> forces <em>swave</em> to run the graph on some dispatcher the stream graph of this example looks like this:</p>
<p>Because nothing prescribes the use of a specific dispatcher <em>swave</em> will assign the default dispatcher to all stages.<br/> If we wanted to we could assign a custom dispatcher by adding a <code>.async(dispatcherName)</code> somewhere. </p>
<h3><a href="#explicit-async-boundaries" name="explicit-async-boundaries" class="anchor"><span class="anchor-link"></span></a>Explicit Async Boundaries</h3>
<p>While simply moving stream execution away from the caller thread is nice it doesn&rsquo;t really help with running things in parallel. In order to do that we need to introduce asynchronous boundaries, which can be done with <a href="../transformations/reference/asyncBoundary.html">asyncBoundary</a>:</p>
<pre><code class="scala">import scala.concurrent.Future
import swave.core.util._
import swave.core._

implicit val env = StreamEnv()

val run: StreamRun[Future[Seq[String]]] =
  Spout.ints(0)
    .filter(_ % 5 == 0)
    .asyncBoundary() // adds an explicit async boundary here
    .map(_.toString)
    .take(10)
    .to(Drain.seq(limit = 100)).run()

run.result.await() shouldEqual (0 to 45 by 5).map(_.toString)

env.shutdownOn(run.termination)</code></pre>
<p><a href="../transformations/reference/asyncBoundary.html">asyncBoundary</a> splits the stream graph into two <em>async regions</em>, which are sub-graphs that run independently from each other on their own dispatchers:</p>
<p>If the default dispatcher is configured to use more than one thread (as it usually is) this stream setup can potentially keep two cores busy, because both async regions can run concurrently on separate threads.</p>
<p>By adding more async boundaries we could further increase the parallelization potential, i.e. possibly increase throughput, at the expense of higher latency because each async boundary introduces some overhead resulting from inter-thread communication. Our toy example here will definitely not benefit from async boundaries because the individual stages are too light-weight. Any benefit from parallelization will be completely outweighed by the async boundary&rsquo;s overhead. In real-world applications however, where the stream stages do actual and potentially heavy work, the ability to quickly and easily add async boundaries at different points and evaluating their effect on application performance is an important tool. </p>
<p>Like <a href="../transformations/reference/async.html">async</a> the <a href="../transformations/reference/asyncBoundary.html">asyncBoundary</a> transformation takes as optional parameter the name of a dispatcher that is to be assigned to all stages in its <em>upstream</em> region. The dispatcher for its downstream region can be defined by a potentially existing other <a href="../transformations/reference/asyncBoundary.html">asyncBoundary</a> further downstream or an <code>.async(dispatcherId)</code> marker. </p>
<h3><a href="#complex-example" name="complex-example" class="anchor"><span class="anchor-link"></span></a>Complex Example</h3>
<p>Of course stream graphs aren&rsquo;t always straight pipelines, so let&rsquo;s look at a more complex example involving several drains and async boundaries as well as custom dispatcher assignments:</p>
<p><img src="../../assets/img/async-graph4.svg" alt="Complex Stream Graph with several Async Boundary" /></p>
<p>As you can see it&rsquo;s possible that both sides of an async boundary belong to the same async region if there is another boundary-less connection.</p>
<p>Here is the code for this (admittedly quite contrived) example:</p>
<pre><code class="scala">import com.typesafe.config.ConfigFactory
import scala.concurrent.{Future, Promise}
import scala.concurrent.duration._
import swave.core.util._
import swave.core._

val config = ConfigFactory.parseString {
  &quot;&quot;&quot;swave.core.dispatcher.definition {
    |  foo.thread-pool.fixed-pool-size = 4
    |  bar.thread-pool.fixed-pool-size = 4
    |}&quot;&quot;&quot;.stripMargin
}
implicit val env = StreamEnv(config = Some(config))

def upperChars(s: String): Spout[Char] =
  Spout(s.iterator).map(_.toUpper)

def drain(promise: Promise[String]): Drain[Char, Unit] =
  Drain.mkString(limit = 100)
    .captureResult(promise)
    .async(&quot;bar&quot;) // same as adding `.async` to all regions this drain is placed in

val result2 = Promise[String]()
val run: StreamRun[Future[String]] =
  upperChars(&quot;Hello&quot;)
    .asyncBoundary(&quot;foo&quot;)
    .fanOutBroadcast()
      .sub.drop(2).concat(upperChars(&quot;-Friend-&quot;).asyncBoundary()).end
      .sub.take(2).asyncBoundary().multiply(2).end
    .fanInConcat()
    .tee(Pipe[Char].asyncBoundary().deduplicate.to(drain(result2)))
    .map(_.toLower)
    .to(Drain.mkString(limit = 100))
    .run() // not using `.drainTo(...)` allows us access to the `StreamRun`

run.result.await(5.seconds) shouldEqual &quot;llo-friend-hhee&quot;
result2.future.await(5.seconds) shouldEqual &quot;LO-FRIEND-HE&quot;

// only shut down when all regions have properly terminated
env.shutdownOn(run.termination)</code></pre>
<p>In stream graphs with more than one async region a graceful shutdown requires attaching to the <code>run.termination</code> (a <code>Future[Unit]</code>), which will only be completed when all parts of the stream graph have fully terminated.</p>
<p>Simply calling <code>env.shutdown</code> as soon as (some) drain result has become available might cause the <code>StreamEnv</code> to shut down its thread-pools before all regions have had the chance to properly run their cleanup code. This might cause the appearance of <code>java.util.concurrent.RejectedExecutionException: Dispatcher &#39;...&#39; has already shut down</code> errors in your logs.</p>
<p>Since this mechanism for shutting down gracefully is so common <em>swave</em> already provides the <code>shutdownOn</code> method on <code>StreamEnv</code>, which internally attaches the shutdown call to the given termination future. </p>
                <div class="nav-next">
                    <p><strong>Next:</strong> <a href="../../usage/further/pipes.html">Pipes</a></p>
                </div>
                <!-- end: page -->
            </div>
        </section>
    </div>
</section>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../../assets/vendor/jquery.browser.mobile/jquery.browser.mobile.js"></script>
<script src="../../assets/vendor/nanoscroller/nanoscroller.js"></script>
<script src="../../assets/vendor/highlight/highlight.js"></script>
<script src="../../assets/js/theme.js"></script>
<script src="../../assets/js/theme.init.js"></script>

</body>
</html>