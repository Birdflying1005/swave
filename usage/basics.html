<!doctype html>
<html class="fixed sidebar-light">
<head>
    <meta charset="UTF-8">

    <title>Basics Â· swave</title>
    <meta name="keywords" content="scala, streams, streaming, reactive, asynchronous, non-blocking" />
    <meta name="description" content='A Reactive Streams infrastructure implementation in Scala'>
    <meta name="author" content="The swave team">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,800|Shadows+Into+Light" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" href="../assets/css/theme.css" />
    <link rel="stylesheet" href="../assets/css/skins/default.css" />
    <link rel="stylesheet" href="../assets/css/theme-custom.css">
    <link rel="stylesheet" href="../assets/vendor/highlight/github.css">

    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="apple-mobile-web-app-title" content="swave.io">
    <meta name="application-name" content="swave.io">
    <meta name="theme-color" content="#ffffff">

    <script src="../assets/vendor/modernizr/modernizr.js"></script>
</head>
<body >
<section class="body">

    <header class="header">
        <div class="logo-container">
            <a href="../index.html" class="logo">
                <img src="../assets/img/swave-logo.svg" height="35" alt="swave" />
            </a>
            <div class="visible-xs toggle-sidebar-left" data-toggle-class="sidebar-left-opened" data-target="html" data-fire-event="sidebar-left-opened">
                <i class="fa fa-bars" aria-label="Toggle sidebar"></i>
            </div>
        </div>

        <div class="header-right hidden-xs">
            <ul class="social-icons">
                <li class="social-icons-github"><a href="https://github.com/sirthias/swave/" target="_blank" title="Github"><i class="fa fa-github"></i></a></li>
                <li class="social-icons-email"><a href="https://groups.google.com/forum/#!forum/swave-user" target="_blank" title="Mailing List"><i class="fa fa-envelope"></i></a></li>
                <li class="social-icons-twitter"><a href="https://twitter.com/swaveio/" target="_blank" title="Twitter"><i class="fa fa-twitter"></i></a></li>
            </ul>
            <div id="talks-link">
                <a href="../introduction/talks-on-swave.html" title="Watch the latest introductory talks for swave!">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>&nbsp;
                    <i class="fa fa-video-camera" aria-hidden="true"></i>&nbsp;Watch an intro talk on swave!&nbsp;
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </header>

    <div class="inner-wrapper">
        <aside id="sidebar-left" class="sidebar-left">

            <div class="sidebar-header">
                <div class="sidebar-title">
                    Content
                </div>
                <div class="sidebar-toggle hidden-xs" data-toggle-class="sidebar-left-collapsed" data-target="html" data-fire-event="sidebar-left-toggle">
                    <i class="fa fa-bars" aria-label="Toggle sidebar"></i>
                </div>
            </div>

            <div class="nano">
                <div class="nano-content">
                    <nav id="menu" class="nav-main" role="navigation">
                        <ul class="nav nav-main">
                          <li class="nav-parent"><a><i class="fa fa-blind" aria-hidden="true"></i><span>Introduction</span></a>
                          <ul class="nav nav-children">
                            <li><a href="../introduction/overview.html">Overview</a></li>
                            <li><a href="../introduction/reactive-streams.html">Reactive Streams</a></li>
                            <li><a href="../introduction/swave-vs-akka-stream.html"><em>swave</em> vs. Akka-Stream</a></li>
                            <li><a href="../introduction/talks-on-swave.html">Talks on <em>swave</em></a></li>
                          </ul></li>
                          <li class="nav-parent nav-expanded nav-active"><a><i class="fa fa-book" aria-hidden="true"></i><span>User Documentation</span></a>
                          <ul class="nav nav-children">
                            <li class="nav-parent"><a>Show-Off</a>
                            <ul class="nav nav-children">
                              <li><a href="../usage/show-off/overview.html">Show-Off Overview</a></li>
                              <li><a href="../usage/show-off/md5.html">MD5 Example</a></li>
                              <li><a href="../usage/show-off/fibonacci.html">Fibonacci Example</a></li>
                            </ul></li>
                            <li><a href="../usage/setup.html">Setup</a></li>
                            <li><a href="../usage/quick-start.html">Quick Start</a></li>
                            <li class="nav-expanded nav-active"><a href="../usage/basics.html">Basics</a></li>
                            <li><a href="../usage/spouts.html">Spouts</a></li>
                            <li><a href="../usage/drains.html">Drains</a></li>
                            <li class="nav-parent"><a>Transformations</a>
                            <ul class="nav nav-children">
                              <li><a href="../usage/transformations/overview.html">Transformations Overview</a></li>
                              <li><a href="../usage/transformations/simple.html">Simple Transformations</a></li>
                              <li><a href="../usage/transformations/fan-ins.html">Fan-Ins</a></li>
                              <li><a href="../usage/transformations/fan-outs.html">Fan-Outs</a></li>
                              <li><a href="../usage/transformations/streams-of-streams.html">Streams-of-Streams</a></li>
                              <li><a href="../usage/transformations/couplings.html">Couplings</a></li>
                              <li><a href="../usage/transformations/reference/index.html">Transformation Reference</a></li>
                            </ul></li>
                            <li class="nav-parent"><a>Further Topics</a>
                            <ul class="nav nav-children">
                              <li><a href="../usage/further/sync-vs-async.html">Sync vs. Async</a></li>
                              <li><a href="../usage/further/pipes.html">Pipes</a></li>
                              <li><a href="../usage/further/modules.html">Modules</a></li>
                              <li><a href="../usage/further/debugging.html">Debugging</a></li>
                              <li><a href="../usage/further/rendering.html">Rendering</a></li>
                              <li><a href="../usage/further/configuration.html">Configuration</a></li>
                              <li><a href="../usage/further/best-practices.html">Best Practices</a></li>
                            </ul></li>
                            <li class="nav-parent"><a>IO Adapters</a>
                            <ul class="nav nav-children">
                              <li><a href="../usage/io/file-io.html">File IO</a></li>
                              <li><a href="../usage/io/tcp.html">Network IO (TCP)</a></li>
                            </ul></li>
                            <li><a href="../usage/swave-core-api.html">API Docs (ScalaDoc)</a></li>
                            <li><a href="../usage/swave-akka-compat/index.html">swave-akka-compat</a></li>
                            <li><a href="../usage/swave-scodec-compat/index.html">swave-scodec-compat</a></li>
                            <li><a href="../usage/swave-testkit/index.html">swave-testkit</a></li>
                          </ul></li>
                          <li><a href="../dev/index.html"><i class="fa fa-cogs" aria-hidden="true"></i><span>Developer Documentation</span></a></li>
                          <li class="nav-parent"><a><i class="fa fa-info-circle" aria-hidden="true"></i><span>Project Info</span></a>
                          <ul class="nav nav-children">
                            <li><a href="../project/license.html">License</a></li>
                            <li><a href="../project/contributing.html">Contributing</a></li>
                            <li><a href="../project/changelog.html">Changelog</a></li>
                            <li><a href="../project/sponsors.html">Sponsors</a></li>
                            <li><a href="../project/references.html">References</a></li>
                          </ul></li>
                          <li><a href="../support.html"><i class="fa fa-users" aria-hidden="true"></i><span>Support</span></a></li>
                        </ul>
                    </nav>
                </div>

                <script>
                    // Maintain Scroll Position
                    if (typeof localStorage !== 'undefined') {
                        if (localStorage.getItem('sidebar-left-position') !== null) {
                            var initialPosition = localStorage.getItem('sidebar-left-position'),
                                    sidebarLeft = document.querySelector('#sidebar-left .nano-content');

                            sidebarLeft.scrollTop = initialPosition;
                        }
                    }
                </script>

            </div>

        </aside>

        <section role="main" class="content-body">
            <header class="page-header">
                <ul class="breadcrumbs">
                  <li><a href="../index.html"><i class="fa fa-home"></i></a></li>
                  <li><a href="../usage/index.html">User Documentation</a></li>
                  <li>Basics</li>
                </ul>
            </header>
            <div id="main-content">
                <!-- start: page -->
<h1><a href="#basics" name="basics" class="anchor"><span class="anchor-link"></span></a>Basics</h1>
<p>In order to be able to work with <em>swave</em> effectively you&rsquo;ll need to have a basic understanding of how <em>swave</em> operates under the hood. With the right mental model it&rsquo;ll be much easier to come up with the initial design of a streaming application as well as find and fix problems later on.</p>
<p>This chapter also introduces some core terminology, which is used throughout the rest of the documentation.</p>
<h2><a href="#streams-as-graphs" name="streams-as-graphs" class="anchor"><span class="anchor-link"></span></a>Streams as Graphs</h2>
<p>A good way to envision a <em>swave</em> stream setup is as a small in-memory network in which all <a href="spouts.html">spouts</a>, <a href="drains.html">drains</a> and <a href="transformations/index.html">transformations</a> are the nodes and data flow along the connections between them, e.g. like this:</p>
<p><img src="../assets/img/basic-stream-graph.svg" alt="Basic Stream Graph" /></p>
<p>The arrows in this diagram show the &ldquo;forward&rdquo; direction, i.e. the direction in which data elements flow through the network. Since the network can also contain cycles (i.e. loops) it formally forms a &ldquo;Directed Graph&rdquo;.</p>
<p>In <em>swave</em> all the basic graph nodes (i.e. <a href="spouts.html">spouts</a>, <a href="transformations/index.html">transformations</a> and <a href="drains.html">drains</a>) are called <strong>Stages</strong>. All communication between stages happens along the graph edges in the form of <strong>Signals</strong>, which travel either in the forward direction (i.e. <strong>downstream</strong> in the same direction as the data elements) or backwards (i.e. <strong>upstream</strong> against the flow of data elements), depending on the signal&rsquo;s type. </p>
<h2><a href="#the-core-signals" name="the-core-signals" class="anchor"><span class="anchor-link"></span></a>The Core Signals</h2>
<p><em>swave</em> implements all stages as small and largely decoupled state machines that are driven by the signals coming in from the neighbouring stages. Once a stream graph is running there are five core types of signals that make everything tick and which almost directly correspond to their counterparts in the <a href="../introduction/reactive-streams.html">Reactive Streams</a> protocol:</p><p class="centered"><img src="../assets/img/five-signals.svg" alt="The five basic Signals" /></p>
<dl>
  <dt>Request(n: <code>Long</code>)
  </dt>
  <dd>Signal flowing upstream which indicates that the downstream stage is ready to receive the next <code>n</code> data elements. The total number of requested elements is called <strong>demand</strong> and the lack thereof is called <strong>backpressure</strong>.</dd>
  <dt>Cancel</dt>
  <dd>Signal flowing upstream which indicates that the downstream stage is no longer interested in receiving data elements and will (potentially) shut down.</dd>
  <dt>OnNext(element)
  </dt>
  <dd>Signal flowing downstream which delivers the next data element to the downstream stage.</dd>
  <dt>OnComplete</dt>
  <dd>Signal flowing downstream which indicates that the upstream stage will not deliver any more data elements and will (potentially) shut down.</dd>
  <dt>OnError(error: <code>Throwable</code>)
  </dt>
  <dd>Signal flowing downstream which indicates that the upstream stage has encountered an error and will shut down.</dd>
</dl>
<p>After a stream is started the machinery is kicked into motion by the first <code>Request</code> signal dispatched (in most cases) by the final <a href="drains.html">Drain</a> at the very end of the pipeline. This <code>Request</code> signal triggers respective state machine actions in the upstream stages which cause the dispatch of more signals that traverse the whole graph in a kind of ripple effect. As a result of this process data elements begin to flow from the spouts towards the drains where they can.</p>
<p>The key thing to realize here is that <strong>nothing will happen unless sufficient demand is signalled from downstream</strong> via one or more <code>Request</code> signals. In most cases you won&rsquo;t have to worry about all the details of this process, but especially when things don&rsquo;t work as expected you might have to understand these lower-level principles in order to <a href="further/debugging.html">debug the problem</a>. </p>
<h2><a href="#stream-life-cycle" name="stream-life-cycle" class="anchor"><span class="anchor-link"></span></a>Stream Life-Cycle</h2>
<p>All stages in <em>swave</em> are single-use, which means that they go through their life-cycle at most <strong>once</strong>.<br/> This section outlines what this life-cycle looks like.</p>
<h3><a href="#connecting-and-closing" name="connecting-and-closing" class="anchor"><span class="anchor-link"></span></a>Connecting and Closing</h3>
<p>When you create a new stage (e.g. a <a href="spouts.html">spout</a> or a <a href="drains.html">drain</a>) it starts out in its initial state, where it accepts connections from other stages on its &ldquo;open ends&rdquo; (also called <strong>ports</strong>). These connections are typically created automatically by the DSL.</p>
<p>Let&rsquo;s look at this simple example:</p>
<pre><code class="scala">val foo: Spout[Char] = Spout(&#39;f&#39;, &#39;o&#39;, &#39;o&#39;)</code></pre><p class="centered"><img src="../assets/img/foo-spout.svg" alt="Spout foo" /></p>
<p>The spout instance <code>foo</code> has no downstream attached yet, i.e. it has one open port. We can attach a <a href="transformations/index.html">transformation</a> to connect the open port to a downstream stage:</p>
<pre><code class="scala">val upperFoo: Spout[Char] = foo.map(_.toUpper)</code></pre><p class="centered"><img src="../assets/img/upper-foo.svg" alt="Spout upperFoo" /></p>
<p>After we&rsquo;ve done this the <code>foo</code> instance is fully connected. Any attempt to reuse it (e.g. by trying to attach another transformation) will fail with an <a href="http://swave.io/api/core/latest/#swave.core.IllegalReuseException">IllegalReuseException</a>. However, attaching the <code>map</code> transformation to the <code>foo</code> instance produces another spout (called <code>upperFoo</code> in this case), which itself has now an unconnected (open) port.</p>
<p>As you can see attaching <a href="transformations/index.html">transformations</a> to <a href="spouts.html">spouts</a> will always connect up some ports but at the same time produce new unconnected ones. Only by attaching <a href="drains.html">drains</a> can a graph become fully <strong>closed</strong>, without any ports left unconnected:</p>
<pre><code class="scala">val piping: Piping[Future[Char]] = upperFoo.to(Drain.head)</code></pre><p class="centered"><img src="../assets/img/simple-piping.svg" alt="Simple Piping" /></p>
<h3><a href="#sealing" name="sealing" class="anchor"><span class="anchor-link"></span></a>Sealing</h3>
<p>As you might have already seen in the <a href="quick-start.html">Quick-Start</a> chapter a graph has to be closed first, by connecting up all open ports, before it can be started. Most of the time this is hard to get wrong because the DSL will only give you a <a href="http://swave.io/api/core/latest/#swave.core.Piping">Piping</a> if the final port is connected to a <a href="drains.html">drain</a>, and a stream can only be started via a <a href="http://swave.io/api/core/latest/#swave.core.Piping">Piping</a>.<br/> Sometimes however, for example when using <a href="transformations/couplings.html">Couplings</a>, there is a chance that some ports are not connected yet when the stream is started. Therefore, just before starting, <em>swave</em> sends a special <code>xSeal</code> signal across all stages of the graph, which causes them to verify their being fully connected. If any port is still unconnected the stream will immediately fail with an <a href="http://swave.io/api/core/latest/#swave.core.UnclosedStreamGraphException">UnclosedStreamGraphException</a>.</p>
<p>A stream graph can only be sealed once. Trying to seal it a second time will result in an <a href="http://swave.io/api/core/latest/#swave.core.IllegalReuseException">IllegalReuseException</a>.</p>
<h3><a href="#starting" name="starting" class="anchor"><span class="anchor-link"></span></a>Starting</h3>
<p>Once the stream setup has been sealed successfully it can be started. It is only at this point, when the stream is started, that any resources are claimed, which are potentially required by a stage in the graph (e.g. a network socket, a file handle or a thread-pool). Before the start, up until and including the sealing, no component in the stream will become active, which means that you are free to inspect it, maybe <a href="further/rendering.html">render</a> it, and potentially drop it without having to worry about any clean-up.</p>
<p>After having been started most stages will either begin to immediately send out signals to their peers or wait for signals from their peers, depending on their own logic and configuration. In the process data elements will start to flow from the <a href="spouts.html">spouts</a> to the <a href="drains.html">drains</a>.</p>
<p>A <a href="http://swave.io/api/core/latest/#swave.core.Piping">Piping</a> can only be started once. Trying to start it a second time will result in an <a href="http://swave.io/api/core/latest/#swave.core.IllegalReuseException">IllegalReuseException</a>.</p>
<h3><a href="#running" name="running" class="anchor"><span class="anchor-link"></span></a>Running</h3>
<p>After having been started the stream will be running until all stages have terminated. &ldquo;Running&rdquo; thereby means that the state machines within the stages wait for signals from their peers (or from the outside) and react with sending signals themselves.</p>
<p>The exact mechanics of how this happens are not necessarily interesting but it is helpful to know the few basic rules that define which signal is allowed to be sent when:</p>
<dl>
  <dt><code>request</code> before <code>cancel</code>
  </dt>
  <dd>There can be zero or more <code>request</code> signals before a <code>cancel</code> signal, but no <code>request</code> after a <code>cancel</code>. A <code>cancel</code> is always the last signal that is sent from a stage to upstream. It is allowed that a stage does not request anything from its upstream and cancels immediately.</dd>
  <dt>No unrequested elements</dt>
  <dd>An upstream is only ever allowed to send as many data elements to a downstream (via <code>onNext</code> signals) as have been previously requested (in total) by that downstream. This means that, without prior demand, no data element can be delivered from the upstream to the downstream.</dd>
  <dt><code>onNext</code> before <code>onComplete</code> or <code>onError</code>
  </dt>
  <dd>There can be zero or more <code>onNext</code> signals before an <code>onComplete</code> or <code>onError</code>, but no <code>onNext</code> afterwards. A termination signal (<code>onComplete</code> or <code>onError</code>) is always the last signal that is sent from a stage to downstream. It is allowed that a stage does not deliver any data to a downstream via <code>onNext</code> but immediately signals termination.</dd>
  <dt>Termination signals don&rsquo;t need demand
  </dt>
  <dd>When an upstream knows that no further data elements will follow it can immediately signal <code>onComplete</code> to its downstream, even when no demand has been previously signalled from there. Similarly, in case of an error a stage usually and immediately signals <code>onError</code> to all its downstreams, cancels its upstreams and shuts down.</dd>
  <dt>Completion is buffered but errors are not</dt>
  <dd>In many cases a stream graph contains explicit or implicit buffers at various points in its stage network. Apart from potentially increasing throughput buffers are sometimes necessary to generate required demand. It is important to understand that <code>onComplete</code> signals are buffered, i.e. queued behind potentially preceding data elements, whereas <code>onError</code> signals are not! This means that errors can (and often do) &ldquo;jump over&rdquo; data elements that were delivered before the error but are still sitting in some buffer.</dd>
</dl>
<h3><a href="#terminating" name="terminating" class="anchor"><span class="anchor-link"></span></a>Terminating</h3>
<p>A stream graph is fully terminated when all its stages have shut down. When exactly a stage shuts down depends on the stage&rsquo;s logic. The basic <a href="spouts.html">spout</a> stages and most simple transformation stages shut down when they have received a <code>cancel</code> from downstream or a termination signal from upstream. However, this is not necessarily the case for <a href="transformations/fan-ins.html">fan-in</a> and <a href="transformations/fan-outs.html">fan-out</a> stages.</p>
<p>Many times you are only interested in completion of the result <code>Future</code> that a final <a href="drains.html">drain</a> produces. However, depending on the stream&rsquo;s execution mode, this might well be before all stages have terminated. It could even be that the stream continues to run indefinitely afterwards if it&rsquo;s set up in a way that allows this.</p>
<h2><a href="#execution-model" name="execution-model" class="anchor"><span class="anchor-link"></span></a>Execution Model</h2>
<p><em>swave</em> streams can run in one of two basic modes:</p>
<ol>
  <li>Synchronously on the caller thread (yet without any blocking!)</li>
  <li>Asynchronously on a thread-pool detached from the caller thread</li>
</ol>
<p>Hereby the caller thread is the thread calling the <code>run</code> method. </p>
<p>Whether a stream runs synchronously or asynchronously depends on the kinds of stages that are present in the graph. By default <em>swave</em> will run the stream synchronously if possible, but certain kinds of stages must react to external signals (like timers or interrupts) and thus cannot operate in a synchronous mode. If at least one of these is present in the graph then the stream will run asynchronously.</p>
<p>Of course you can also force a stream to run asynchronously in various ways. Check out the chapter on <a href="further/sync-vs-async.html">Sync vs. Async Execution</a> for more details on this.</p>
<h2><a href="#thread-safety" name="thread-safety" class="anchor"><span class="anchor-link"></span></a>Thread Safety</h2>
<p>While the running of streams is specifically designed for asynchronous execution the DSL for constructing stream graphs is not. This means that, if you (for example) try to reuse a stage from two different threads without proper synchronization, the behavior you see might be unexpected.</p>
<p>The DSL is designed for use from only one thread at a time. If you share DSL elements across threads you must make sure to properly synchronize all accesses yourself.</p>
                <div class="nav-next">
                    <p><strong>Next:</strong> <a href="../usage/spouts.html">Spouts</a></p>
                </div>
                <!-- end: page -->
            </div>
        </section>
    </div>
</section>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="../assets/vendor/jquery.browser.mobile/jquery.browser.mobile.js"></script>
<script src="../assets/vendor/nanoscroller/nanoscroller.js"></script>
<script src="../assets/vendor/highlight/highlight.js"></script>
<script src="../assets/js/theme.js"></script>
<script src="../assets/js/theme.init.js"></script>

</body>
</html>